==========================================================================================================================================================================
                                                                            WARP DIVERGENCE
==========================================================================================================================================================================

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                              The Problem
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

PC - Program countner (id of instruction)
Warp - fixed by hardware set of 32 consectuive threads. Each thread has the same PC in warp in given cycle.
Mask - 32 length bit number, set bit on n-th position indicates that n-th thread is active. Unset bit indicates that the given thread is idle

Let us consider the following example:

                  PC: A
                  if(cond) {
                    PC: B
                  } else {
                    PC: C
                  }
                  PC: D

On the warp level it looks as follows:

PC: A            PC: B                 PC: C                PC: D
Cycle X          Cycle X+1             Cycle X+2            Cycle X+3
------->         --------->            IDLE                 ---------->
------->         --------->            IDLE                 ---------->
........         ..........            .........            ...........
------->          IDLE                 --------->           ---------->
------->          IDLE                 --------->           ---------->
                                                            Re-divergence


Divergence lead to loss performance. Actual GPU hardware cannot ommit divergence (if condition is evaluated in runtime, so it is hard to predict how many threads
will run one branch and how many second branch). Desplite of this we can optimizing branch divergence by grouping maximum threads from one branch into one SIMD and from 
second branch into other SIMD. This gives us great achivement in particular in the case where we have multiple divergence with branches contains several instructions.


------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                      Optimizing divergence
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                     Dynamic Warp Formation
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Let us consider the following example
(assume that warp is 4 threads, each PC instruction is executed by two warps, i.e x and y)

      PC: A                            PC: A      PC: A     PC: B     PC: B     PC: C     PC: C      PC: D     PC: D    PC: E     PC: E     PC: F      PC: F
        x/1111                         warp x     warp y    warp x    warp y    warp x    warp y     warp x    warp y   warp x    warp y    warp x     warp y
        y/1111                         ----->     ----->    ----->    idle      ------>   idle       idle      idle     ----->    idle      idle       ----->
      if(cond1) {                      ----->     ----->    ----->    idle      idle      idle       ------>   idle     ----->    idle      idle       ----->
        PC: B                          ----->     ----->    ----->    ----->    idle      ------>    ------>   idle     ----->    ----->    idle       idle
          x/1110                       ----->     ----->    idle      ----->    idle      idle       idle      ----->   idle      ----->    ----->     idle
          y/0011
        if(cond2) {
          PC: C                        PC: G       PC: G     PC: A
            x/1000                     warp x      warp y
            y/0010                     ----->      ----->
        } else {                       ----->      ----->
          PC: D                        ----->      ----->
            x/0110                     ----->      ----->
            y/0001
        }                              We can seen much divergence and highly underutilzed warps. We can improve this. Let us focus on PC: D
        PC: E                          
          x/1110                      Baseline:                                     Dynamic Warp Formation
          y/0011                                                                      
      } else {                        PC: D       PC: D                              PC: D
        PC: F                         warp x      warp y                             warp x && warp y
          x/0001                      idle        idle                               idle
          y/1100                      ----->      idle            ======>            ------->
      PC: G                           ----->      idle                               ------->
        x/1111                        idle        ----->                             ------->
        y/1111
        goto A
